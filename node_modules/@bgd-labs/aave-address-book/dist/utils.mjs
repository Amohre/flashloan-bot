var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// src/ts/utils.ts
import { getAddress } from "viem";
import * as addresses from "./AaveAddressBook.mjs";
function flattenObject(obj, parentKey = "", result = {}) {
  for (const [key, value] of Object.entries(obj)) {
    const newKey = parentKey ? `${parentKey}.${key}` : key;
    if (value !== null && typeof value === "object" && !Array.isArray(value)) {
      flattenObject(value, newKey, result);
    } else {
      result[newKey] = value;
    }
  }
  return result;
}
function getAddressBookReferences(value, chainId) {
  const transformedAddresses = Object.keys(addresses).reduce(
    (acc, key) => {
      if (addresses[key].CHAIN_ID === chainId) {
        const chainAddresses = __spreadValues({}, addresses[key]);
        if (chainAddresses.E_MODES) {
          delete chainAddresses.E_MODES;
        }
        return __spreadValues(__spreadValues({}, acc), flattenObject({ [key]: chainAddresses }));
      }
      return acc;
    },
    {}
  );
  return Object.keys(transformedAddresses).filter(
    (key) => transformedAddresses[key] === getAddress(value)
  );
}
export {
  getAddressBookReferences
};
//# sourceMappingURL=utils.mjs.map